---
title: "Tp_movilidad_cdde2"
author: "Lucas S. Melfi"
date: "2025-05-31"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r Librerías}
library(tidyverse)
library(here)
library(sf)
library(nngeo)
library(leaflet)
library(fs)
library(osmdata)
library(osrm)
library(openrouteservice)
```


```{r Urls}


url_barrios2 <- "https://cdn.buenosaires.gob.ar/datosabiertos/datasets/ministerio-de-desarrollo-humano-y-habitat/barrios-populares"

url_comunas <- "https://cdn.buenosaires.gob.ar/datosabiertos/datasets/ministerio-de-educacion/comunas/comunas.geojson"

url_barrioscaba <- "https://cdn.buenosaires.gob.ar/datosabiertos/datasets/ministerio-de-educacion/barrios/barrios.geojson"

url_educativos <- "https://cdn.buenosaires.gob.ar/datosabiertos/datasets/ministerio-de-educacion/establecimientos-educativos/establecimientos_educativos.geojson"

url_radiocensalcaba <- "https://cdn.buenosaires.gob.ar/datosabiertos/datasets/direccion-general-de-estadisticas-y-censos/informacion-censal-por-radio/caba_radios_censales.geojson"

url_radiosamba <- "https://cdn.produccion.gob.ar/cdn-cep/amba-aportantes/Shapes.rar"

url_radiosocioeco <- "https://cdn.produccion.gob.ar/cdn-cep/amba-aportantes/Empleo-AMBA.csv"



```

#Barrios de clase media y alta de Ciudad Autonoma de Buenos Aires

```{r Carga de Mapa base Radio Censales AMBA}

td <- tempdir()
rar_path <- path(td, "Shapes.rar")
download.file(url = url_radiosamba, destfile = rar_path, mode = "wb")
system(paste('"D:/PROGRAMS-HDD/WinRAR/WinRAR.exe" x', shQuote(rar_path), shQuote(td)))
list.files(td, pattern = "\\.shp$", recursive = TRUE)
radios2 <- read_sf(path(td, "Shapes", "Shape AMBA.shp"))
list.files(td, recursive = TRUE)
rm(td)
st_crs(radios2)
sum(!st_is_valid(radios2))
radios2 <- st_transform(radios2, 5347)
```


```{r Carga Dataset ingreso medio AMBA (2022)}

radio_socioeco <- read.csv(url_radiosocioeco, fileEncoding = "latin1")
```

```{r Join Espacial con No espacial: Radio Censales e Ingreso}

mapa_eco <- left_join(radios2, radio_socioeco, by = c("CO_FRAC_RA" = "LINK" ) ) %>%
  filter(!is.na(Remuneracion_media)) 
rm(radio_socioeco)
```


```{r Clasificacion por de ingreso en cuartiles}
cuartiles <- quantile(mapa_eco$Remuneracion_media, probs = c(0.25, 0.50, 0.75), na.rm = TRUE)
bairescm_q <- mapa_eco %>%
  filter(provincia_id == 2, Remuneracion_media > 30000) %>%
  mutate(cluster = case_when(
    Remuneracion_media <= cuartiles[1] ~ "Clase baja",
    Remuneracion_media <= cuartiles[2] ~ "Clase media",
    Remuneracion_media <= cuartiles[3] ~ "Clase media alta",
    TRUE ~ "Clase alta"
  ))


```


```{r}
#Cargamos el mapa de barrios y le transformamos el crs
barrioscm_caba <- st_read(url_barrioscaba)
st_crs(barrioscm_caba)
sum(!st_is_valid(barrioscm_caba))
barrioscm_caba <- st_transform(barrioscm_caba, 5347)


```

```{r Carga de mapa de barruis y join con radiocensales con seleccion de columnas}

barrios_cm_sj <- st_join(bairescm_q, barrioscm_caba, join = st_intersects)

barrioscm_sjs <- barrios_cm_sj %>%
  select(CO_FRAC_RA, geometry, Remuneracion_media, cluster, nombre, comuna, perimetro_, area_metro) %>%
  rename(barrios_nom = nombre)
```

```{r}
barrioscm_sjs_simpl <- barrioscm_sjs %>%
  st_simplify(dTolerance = 50)  
```


```{r Agrupación y filtrado radiocensales por barrio con toma de  muestra}
#Agrupamos por barrios y filtramos los que nos interesan 
barrioscm_fil <- barrioscm_sjs %>%
  filter(barrios_nom == "Palermo" & cluster == "Clase alta" | 
           barrios_nom == "Caballito" & cluster == "Clase media alta"|
           barrios_nom == "Almagro" & cluster == "Clase media" ) %>%
  group_by(barrios_nom) %>%
  arrange(desc (Remuneracion_media)) %>%
  slice_head(n=8) %>%
  ungroup()
#rm(barrioscm_sjs)
```

```{r Primera visualizacion: radiocensales elegidos de CABA  }

#Cargamos un mapa de radiocensales de CABA para que nos oficie de mapa base para la visualización
radio_bsas <-  st_read(url_radiocensalcaba)
st_crs(radio_bsas)
sum(!st_is_valid(radio_bsas))
radio_bsas <- st_transform(radio_bsas, 5347)

#Visualizamos
ggplot() + 
  geom_sf(data = radio_bsas, fill = "grey90", color = "black") +
  geom_sf(data = barrioscm_fil, aes(fill = barrios_nom), color = "white", size = 0.2) +
  scale_fill_brewer(palette = "Set1") +
  theme_minimal()
```



```{r}
#cargamos las escuelas
educ <- st_read(url_educativos)
sum(!st_is_valid(educ))
educ <- st_transform(educ, 5347) %>% 
  select(escuela = nam , tipo_gestion = ges,  nivel = nen_mde, tipo = tip, geom_edu = geometry)

educ_sna <- educ %>% filter(!is.na(tipo_gestion)) #sacamos los na
rm(educ)
```


```{r Buffers y conteo}
barrioscm_sjs_pts <- barrioscm_sjs %>%
  st_point_on_surface() #Trabajamos con geometria de punto para reducir el costo computacional

barrioscm_filp <- barrioscm_sjs_pts %>%
  filter(barrios_nom == "Palermo" & cluster == "Clase alta" | 
           barrios_nom == "Caballito" & cluster == "Clase media alta"|
           barrios_nom == "Almagro" & cluster == "Clase media" ) %>%
  group_by(barrios_nom) %>%
  arrange(desc (Remuneracion_media)) %>%
  slice_head(n=8) %>%
  ungroup()
buff_cm_500  <- barrioscm_filp %>% st_buffer(500)  %>% mutate(buffer = "500m")
buff_cm_1000 <- barrioscm_filp %>% st_buffer(1000) %>% mutate(buffer = "1000m")
buff_cm_2000 <- barrioscm_filp %>% st_buffer(2000) %>% mutate(buffer = "2000m")

buffers_cm_bind <- bind_rows(buff_cm_500, buff_cm_1000, buff_cm_2000)
escuelas_cm_filtro <- st_filter(educ_sna, buffers_cm_bind)
escuelas_cmbuffer <- st_join(escuelas_cm_filtro, buffers_cm_bind, join = st_intersects)
conteo_escuelas_cm <- escuelas_cmbuffer %>%
  group_by(barrios_nom, buffer) %>%
  summarise(total = n(), .groups = "drop")
```


```{r Grafico de conteo}

ggplot(conteo_escuelas_cm, aes(x = barrios_nom, y = total, fill = buffer)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_manual(values = c(
    "500m" = "#1b9e77",    
    "1000m" = "#d95f02",   
    "2000m" = "#7570b3"    
  )) +
  labs(title = "Escuelas cercanas a barrios de clase media/alta",
       x = "Barrio", y = "Cantidad de escuelas", fill = "Distancia") +
  theme_minimal()


```


```{r}
ggplot(conteo_escuelas_cm, aes(x = buffer, y = total, fill = buffer)) +
  geom_col() +
  facet_wrap(~barrios_nom) +
  labs(
    title = "Escuelas dentro del radio de cada barrio",
    x = "Distancia",
    y = "Cantidad de escuelas"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```



```{r Segunda visualización: Mapa de buffers y escuelas}
ggplot() +
  # Mapa base
  geom_sf(data = radio_bsas, fill = "grey90", color = "black", size = 0.1) +
  
  # Buffers con transparencia
  geom_sf(data = buffers_cm_bind, 
          aes(fill = buffer), 
          color = "red", alpha = 0.2) +
  
  # Escuelas dentro de los buffers
  geom_sf(data = escuelas_cmbuffer, 
          aes(color = tipo_gestion), 
          size = 2) +
 
  # Colores para buffers y gestión
  scale_fill_manual(values = c("500m" = "blue", 
                               "1000m" = "skyblue", 
                               "2000m" = "red")) +
  scale_color_manual(values = c("Privada" = "purple", 
                                "Estatal" = "green")) +
  
  labs(title = "Escuelas dentro de buffers de radios censales",
       subtitle = "Buffers a 500m, 1000m y 2000m - Colores por gestión",
       fill = "Distancia",
       color = "Gestión") +
  
  theme_minimal()

```
```{r Tercera visualización: Facetado de buffers y escuelas}
ggplot() +
  geom_sf(data = radio_bsas, fill = "grey90", color = "black", size = 0.1) +
  # Buffers
  geom_sf(data = buffers_cm_bind, 
          aes(fill = buffer), 
          color = NA, alpha = 0.3) +
  
  # Escuelas dentro de buffers
  geom_sf(data = escuelas_cmbuffer, 
          aes(color = tipo_gestion), 
          size = 1, alpha=0.1) +
  
  scale_fill_manual(values = c("500m" = "blue", 
                               "1000m" = "skyblue", 
                               "2000m" = "red")) +
  scale_color_manual(values = c("Privada" = "purple", 
                                "Estatal" = "green")) +
  
  labs(title = "Escuelas dentro de buffers de radios censales",
       subtitle = "Facetado por barrio",
       fill = "Distancia",
       color = "Gestión") +
  
  theme_minimal() +
  facet_wrap(~ barrios_nom)

```
```{r}
buffers_cm_bind_wgs <- st_transform(buffers_cm_bind, 4326)
escuelas_cmbuffer_wgs <- st_transform(escuelas_cmbuffer, 4326)
barrioscm_filp_wgs <- st_transform(barrioscm_filp, 4326)


leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  
  # Buffers (colores por distancia)
  addPolygons(data = buffers_cm_bind_wgs,
              fillColor = ~case_when(
                buffer == "500m" ~ "blue",
                buffer == "1000m" ~ "skyblue",
                buffer == "2000m" ~ "red"
              ),
              fillOpacity = 0.1,
              color = "black",
              weight = 1,
              group = "Buffers") %>%
  
  # Escuelas (colores por gestión)
  addCircleMarkers(data = escuelas_cmbuffer_wgs,
                   radius = 4,
                   color = ~case_when(
                     tipo_gestion == "Estatal" ~ "green",
                     tipo_gestion == "Privada" ~ "purple",
                     TRUE ~ "gray"
                   ),
                   stroke = FALSE,
                   fillOpacity = 0.7,
                   popup = ~paste0("<b>Escuela: </b>", escuela,
                                   "<br><b>Gestión: </b>", tipo_gestion),
                   group = "Escuelas") %>%
  
  # Centroides (opcional)
  addCircleMarkers(data = barrioscm_filp_wgs,
                   radius = 5,
                   color = "red",
                   fill = TRUE,
                   fillOpacity = 1,
                   stroke = TRUE,
                   weight = 1,
                   popup = ~paste0("<b>Barrio: </b>", barrios_nom),
                   group = "Centroides") %>%
  addLegend(
    position = "bottomright",
    colors = c("red", "orange", "blue"),
    labels = c("0-500m", "500-1000m", "1000-2000m"),
    title = "Rango de distancia"
  )%>%
  
  # Control de capas
  addLayersControl(
    overlayGroups = c("Buffers", "Escuelas", "Centroides"),
    options = layersControlOptions(collapsed = FALSE)
  )

```


```{r}
# 1. Filtrar escuelas dentro de cada buffer
escuelas_cm_500 <- st_filter(educ_sna, buff_cm_500)
escuelas_cm_1000 <- st_filter(educ_sna, buff_cm_1000)
escuelas_cm_2000 <- st_filter(educ_sna, buff_cm_2000)

# 2. Configurar OSRM en modo a pie
options(osrm.profile = "foot")

# 3. Transformar a CRS 4326
barrioscm_filp <- st_transform(barrioscm_filp, 4326)
escuelas_cm_500 <- st_transform(escuelas_cm_500, 4326)
escuelas_cm_1000 <- st_transform(escuelas_cm_1000, 4326)
escuelas_cm_2000 <- st_transform(escuelas_cm_2000, 4326)

# 4. Calcular tiempos para 500m
tabla_tiempos_cm_500 <- osrmTable(src = barrioscm_filp, dst = escuelas_cm_500)
df_tiempos_cm_500 <- as.data.frame(tabla_tiempos_cm_500$durations)
df_tiempos_cm_500$radio_id <- rownames(df_tiempos_cm_500)
df_tiempos_cm_largo_500 <- df_tiempos_cm_500 %>%
  pivot_longer(cols = -radio_id, names_to = "escuela_id", values_to = "tiempo_min") %>%
  mutate(buffer = "500m")

# 5. Calcular tiempos para 1000m
tabla_tiempos_cm_1000 <- osrmTable(src = barrioscm_filp, dst = escuelas_cm_1000)
df_tiempos_cm_1000 <- as.data.frame(tabla_tiempos_cm_1000$durations)
df_tiempos_cm_1000$radio_id <- rownames(df_tiempos_cm_1000)
df_tiempos_cm_largo_1000 <- df_tiempos_cm_1000 %>%
  pivot_longer(cols = -radio_id, names_to = "escuela_id", values_to = "tiempo_min") %>%
  mutate(buffer = "1000m")

# 6. Calcular tiempos para 2000m
tabla_tiempos_cm_2000 <- osrmTable(src = barrioscm_filp, dst = escuelas_cm_2000)
df_tiempos_cm_2000 <- as.data.frame(tabla_tiempos_cm_2000$durations)
df_tiempos_cm_2000$radio_id <- rownames(df_tiempos_cm_2000)
df_tiempos_cm_largo_2000 <- df_tiempos_cm_2000 %>%
  pivot_longer(cols = -radio_id, names_to = "escuela_id", values_to = "tiempo_min") %>%
  mutate(buffer = "2000m")

# 7. Unir resultados
df_tiempos_cm_final <- bind_rows(df_tiempos_cm_largo_500,
                                 df_tiempos_cm_largo_1000,
                                 df_tiempos_cm_largo_2000)

```


```{r Preparacion Geoconsulta}
options(osrm.profile = "foot") #Perfil de la geconsulta, tiempo de traslado a pie.

barrioscm_filp <- st_transform(barrioscm_filp, 4326) #Convertir a crs legible para OSRM
escuelas_cm_500 <- st_transform(escuelas_cm_500, 4326)
escuelas_cm_1000 <- st_transform(escuelas_cm_1000, 4326)
escuelas_cm_2000 <- st_transform(escuelas_cm_2000, 4326) 

```

```{r Geoconsulta tiempos a pie }
# 500 m
tabla_tiempos_cm_500 <- osrmTable(src = barrioscm_filp, dst = escuelas_cm_500)
df_tiempos_cm_500 <- as.data.frame(tabla_tiempos_cm_500$durations) %>%
  tibble::rownames_to_column("radio_id") %>%
  pivot_longer(cols = -radio_id, names_to = "escuela_id", values_to = "tiempo_min") %>%
  mutate(buffer = "500m")

# 1000 m
tabla_tiempos_cm_1000 <- osrmTable(src = barrioscm_filp, dst = escuelas_cm_1000)
df_tiempos_cm_1000 <- as.data.frame(tabla_tiempos_cm_1000$durations) %>%
  tibble::rownames_to_column("radio_id") %>%
  pivot_longer(cols = -radio_id, names_to = "escuela_id", values_to = "tiempo_min") %>%
  mutate(buffer = "1000m")

# 2000 m
tabla_tiempos_cm_2000 <- osrmTable(src = barrioscm_filp, dst = escuelas_cm_2000)
df_tiempos_cm_2000 <- as.data.frame(tabla_tiempos_cm_2000$durations) %>%
  tibble::rownames_to_column("radio_id") %>%
  pivot_longer(cols = -radio_id, names_to = "escuela_id", values_to = "tiempo_min") %>%
  mutate(buffer = "2000m")

```


```{r}

conteo_escuelasbarrios <- barrios_educ %>%
  group_by(barrios_nom, distancia) %>%  # reemplazá ID_barrio por la columna que identifica barrios
  summarize(cantidad_escuelas = n(), .groups = "drop")
```


#Barrios Populares de Ciudad Autonoma de Buenos Aires

```{r Barrios Populares}
td <- tempdir()
  download.file(url = paste(url_barrios2,
                            "barrios-populares-badata.zip",
                            sep = "/"),
                destfile = fs::path(td, "barrios-populares-badata.zip") )
  unzip(zipfile = fs::path(td, "barrios-populares-badata.zip"),
        exdir = td)
  barrios_vul <- read_sf(fs::path(td, "barrios_vulnerables.shp"))
  rm(td)  
st_crs(barrios_vul)
sum(!st_is_valid(barrios_vul))
barrios_vul <- st_transform(barrios_vul, 5347)
   

```
#Barrios populares 
Capa que contiene el registro de los denominados barrios poulares de la Ciudad Autonoma de Buenos Aires. Dichos barrios son considerados las zonas precarias y vulnerables.
#TIPO_ASENT		
Tipo de registro: Villa, Asentamiento precario, Barrio municipal, Barrio urbanizado, Conjunto habitacional, Núcleo habitacional transitorio. Son categorías definidas según el Ministerio de Desarrollo y Hábitat en Junio de 2020.


```{r}
#Primera visualizacion barrios pop en radio censales
ggplot() +
  geom_sf(data = radio_bsas, fill = "grey90", color = "black", size = 0.1) +
  geom_sf(data = barrios_vul, fill = "red", color = "red", alpha = 1) +
  labs(title = "Ubicación de barrios populares  de CABA - Radiocensales",
       fill = "Comuna") +
  theme_minimal()
```
```{r}
leaflet() %>%
  addProviderTiles("CartoDB.Positron") %>%
  addPolygons(data = st_transform (comunas, 4326),
              fillColor = "transparent",
              color = "black",
              weight = 1,
              label = ~comuna)%>%
  addPolygons(data = st_transform (barrios_vul,4326),
              fillColor = "red",
              color = "darkred",
              weight = 1,
              fillOpacity = 0.6,
              label = ~barrios)
```



#Barrios populares 
Capa que contiene el registro de los denominados barrios poulares de la Ciudad Autonoma de Buenos Aires. Dichos barrios son considerados las zonas precarias y vulnerables.
#TIPO_ASENT		
Tipo de registro: Villa, Asentamiento precario, Barrio municipal, Barrio urbanizado, Conjunto habitacional, Núcleo habitacional transitorio. Son categorías definidas según el Ministerio de Desarrollo y Hábitat en Junio de 2020.

#Comunas
Este conjunto de datos proporciona información sobre la ubicación, perímetro y área de las comunas de la Ciudad de Buenos Aires, establecidas a partir de la Ley Orgánica de Comunas (Ley Nº 1777/2005). La información permite analizar la distribución territorial y la organización administrativa de la ciudad, facilitando estudios de planificación urbana y gestión pública.



```{r Operaciones}
#Hacemos el space join entre los barrios y los radiocensales, para unir solo las partes de la geometria, es decir los radiocensales, que se intersectan con los barrios populares
radios2 <- st_transform(radios2, 5347)
barrios_vul <- st_transform(barrios_vul, 5347)
barrios_vul_rs <- st_join(barrios_vul, radios2, join = st_intersects) 


barrios_vul_selec <- barrios_vul_rs %>% filter(NOMBRE %in% c("Villa 31","Villa 31 - Padre Mugica", "Villa 21-24", "Villa 15 - Ciudad Oculta")) %>%
  mutate(NOMBRE = case_when(
    NOMBRE == "Villa 15 - Ciudad Oculta" ~ "Villa_15",
    NOMBRE == "Villa 31 - Padre Mugica" ~ "Villa_31",
    NOMBRE == "Villa 31 - Padre Mugica" ~ "Villa_31",
    NOMBRE == "Villa 21-24" ~ "Villa_21_24"
  ))  %>%
  rename(barrios_nom = NOMBRE)
 #Renombramos para que sea mas facil manejar el dato

barrios_vul_selec <- barrios_vul_selec %>%
  mutate(barrios_nom = coalesce(barrios_nom, "Villa_31")) #esto para que renombre los NA como Villa 31 que es el primer string
rm(barrios_vul)
rm(barrios_vul_rs)

#write.csv(barrios_vul_selec, "barrios_vul_selec.csv", row.names = TRUE)




```

```{r}
#Esto lo hacemos para no pagar tanto costo computacional en las oepraciones, sobre todo geoconsultas
barrios_vul_puntos <- barrios_vul_selec %>%
  st_point_on_surface() %>%
  select(Id, barrios_nom, CO_FRAC_RA, TIPO_ASENT,MANZANA, Superficie, geometry)  # Ajustá según tus columnas
  
#Agrupamos y tomamos los 8 radiocensales mas extensos en superficie de cada barrio popular
radios_vul8 <- barrios_vul_puntos %>% 
  group_by(barrios_nom) %>% 
  arrange(desc(Superficie)) %>% 
  slice_head(n = 8) %>%
  ungroup()

buff_vul_500  <- barrios_vul_puntos %>% st_buffer(500)  %>% mutate(buffer = "500m")
buff_vul_1000 <- barrios_vul_puntos %>% st_buffer(1000) %>% mutate(buffer = "1000m")
buff_vul_2000 <- barrios_vul_puntos %>% st_buffer(2000) %>% mutate(buffer = "2000m")
buffers_vul_bind <- bind_rows(buff_vul_500, buff_vul_1000, buff_vul_2000)
escuelas_vul_filto <- st_filter(educ_sna, buffers_vul_bind)
escuelas_vulbuffer <- st_join(escuelas_vul_filto, buffers_vul_bind, join = st_intersects)
conteo_escuelasvulpun <- escuelas_vulbuffer %>%
  group_by(escuela, buffer, barrios_nom) %>%
  summarise(total = n())

```
```{r}
ggplot(conteo_escuelasvulpun, aes(x = barrios_nom, y = total, fill = buffer)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_manual(values = c(
    "500m" = "#1b9e77",    
    "1000m" = "#d95f02",   
    "2000m" = "#7570b3"    
  )) +
  labs(title = "Escuelas cercanas a barrios de clase media/alta",
       x = "Barrio", y = "Cantidad de escuelas", fill = "Distancia") +
  theme_minimal()
```
```{r}
ggplot(conteo_escuelasvulpun, aes(x = buffer, y = total, fill = buffer)) +
  geom_col() +
  facet_wrap(~barrios_nom) +
  labs(
    title = "Escuelas dentro del radio de cada barrio",
    x = "Distancia",
    y = "Cantidad de escuelas"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```



```{r Visualización: Buffers y escuelas de barrios vulnerables}
ggplot() +
  geom_sf(data = radio_bsas, fill = "grey95", color = "black") +
  geom_sf(
    data = anillos2,
    aes(fill = buffer),
    color = "black",
    alpha = 0.1
  ) +
  geom_sf(
    data = escuelas_vulbuffer, 
    aes(color = tipo_gestion), 
    size = 1
  ) +
  scale_fill_manual(
    values = c("0-500m" = "red", "500-1000m" = "orange", "1000-2000m" = "blue")
  ) +
  theme_minimal() +
  labs(
    title = "Escuelas dentro de anillos de barrios vulnerables",
    fill = "Rango de distancia",
    color = "Tipo de gestión"
  )
```

```{r}
ggplot() +
  geom_sf(data = radio_bsas, fill = "grey95", color = "black") +
  geom_sf(
    data = anillos2,
    aes(fill = buffer),
    color = "black",
    alpha = 0.1
  ) +
  geom_sf(
    data = escuelas_vulbuffer, 
    aes(color = tipo_gestion), 
    size = 1
  ) +
  scale_fill_manual(
    values = c("0-500m" = "red", "500-1000m" = "orange", "1000-2000m" = "blue")
  ) +
  theme_minimal() +
  labs(
    title = "Escuelas dentro de anillos de barrios vulnerables",
    fill = "Rango de distancia",
    color = "Tipo de gestión"
  ) +
  facet_wrap(~ barrios_nom)  # 👈 facetado por barrio

```




```{r}
leaflet() %>%
  addProviderTiles("CartoDB.Positron") %>%
  
  # Base: radio de Buenos Aires
  addPolygons(
    data = st_transform(radio_bsas, 4326),
    fillColor = "transparent",
    color = "black",
    weight = 1,
    fillOpacity = 0.5,
    label = ~"CABA"
  ) %>%
  
  # Anillos con colores
  addPolygons(
    data = st_transform(anillos2, 4326),
    fillColor = ~case_when(
      buffer == "0-500m" ~ "red",
      buffer == "500-1000m" ~ "orange",
      buffer == "1000-2000m" ~ "blue",
      TRUE ~ "transparent"
    ),
    color = "black",
    weight = 1,
    fillOpacity = 0.2,
    label = ~buffer
  ) %>%
  
  # Escuelas como puntos
  addCircleMarkers(
    data = st_transform(escuelas_vulbuffer, 4326),
    color = ~ifelse(tipo_gestion == "Privada", "blue", "green"),
    radius = 2,
    fillOpacity = 0.8,
    popup = ~paste("Escuela:", escuela, "<br>",
                   "Tipo gestión:", tipo_gestion)
  ) %>%
  
  addLegend(
    position = "bottomright",
    colors = c("red", "orange", "blue"),
    labels = c("0-500m", "500-1000m", "1000-2000m"),
    title = "Rango de distancia"
  ) %>%
  addLayersControl(
    overlayGroups = c("Buffers", "Escuelas", "Centroides"),
    options = layersControlOptions(collapsed = FALSE)
  )

```





```{r Visualizaciones}

#Para visualizar no lo podemos hacer por puntos dado que queda muy superpuesto, hay que bufferear de vuelta

radios_union <- barrios_vul_selec %>%
  group_by(barrios_nom) %>%
  summarise(geometry = st_union(geometry))
buff_500  <- st_buffer(radios_union, 500) %>% mutate(buffer = "0-500m")
buff_1000 <- st_buffer(radios_union, 1000) %>% mutate(buffer = "0-1000m")
buff_2000 <- st_buffer(radios_union, 2000) %>% mutate(buffer = "0-2000m")
anillos2 <- bind_rows(
  buff_500,
  st_difference(buff_1000, buff_500) %>% mutate(buffer = "500-1000m"),
  st_difference(buff_2000, buff_1000) %>% mutate(buffer = "1000-2000m")
)
escuelas_cm_filtro <- st_filter(educ_sna, anillos2)
escuelas_cmbuffer <- st_join(escuelas_cm_filtro, buffers_cm_bind, join = st_intersects)

ggplot() +
  geom_sf(data = radio_bsas, fill = "grey95", color = "black") +
  geom_sf(
    data = anillos2,
    aes(fill = buffer),
    color = "black",
    alpha = 0.1
  ) +
  geom_sf(
    data = escuelas_vulbuffer, 
    aes(color = tipo_gestion), 
    size = 1
  ) +
  scale_fill_manual(
    values = c("0-500m" = "red", "500-1000m" = "orange", "1000-2000m" = "blue")
  ) +
  theme_minimal() +
  labs(
    title = "Escuelas dentro de anillos de barrios vulnerables",
    fill = "Rango de distancia",
    color = "Tipo de gestión"
  )



```





```{r}
#Conteo
conteo_esc_bpop <- barrios_vul_educ %>%
  group_by(NOMBRE, distancia) %>%  # reemplazá ID_barrio por la columna que identifica barrios
  summarize(cantidad_escuelas = n(), .groups = "drop") %>%
  arrange(NOMBRE, distancia)


```


```{r}

# 1. Filtrar escuelas dentro de cada buffer
escuelas_500 <- st_filter(educ_sna, buff_vul_500)
escuelas_1000 <- st_filter(educ_sna, buff_vul_1000)
escuelas_2000 <- st_filter(educ_sna, buff_vul_2000)

# 2. Configurar OSRM en modo a pie
options(osrm.profile = "foot")

# 3. Transformar todos los datos a CRS 4326 (WGS84)
radios_vul8 <- st_transform(radios_vul8, 4326)
escuelas_500 <- st_transform(escuelas_500, 4326)
escuelas_1000 <- st_transform(escuelas_1000, 4326)
escuelas_2000 <- st_transform(escuelas_2000, 4326)

# 4. Calcular tiempos para 500m
tabla_tiempos_500 <- osrmTable(src = radios_vul8, dst = escuelas_500)
df_tiempos_500 <- as.data.frame(tabla_tiempos_500$durations)
df_tiempos_500$radio_id <- rownames(df_tiempos_500)
df_tiempos_largo_500 <- df_tiempos_500 %>%
  pivot_longer(cols = -radio_id, names_to = "escuela_id", values_to = "tiempo_min") %>%
  mutate(buffer = "500m")

# 5. Calcular tiempos para 1000m
tabla_tiempos_1000 <- osrmTable(src = radios_vul8, dst = escuelas_1000)
df_tiempos_1000 <- as.data.frame(tabla_tiempos_1000$durations)
df_tiempos_1000$radio_id <- rownames(df_tiempos_1000)
df_tiempos_largo_1000 <- df_tiempos_1000 %>%
  pivot_longer(cols = -radio_id, names_to = "escuela_id", values_to = "tiempo_min") %>%
  mutate(buffer = "1000m")

# 6. Calcular tiempos para 2000m
tabla_tiempos_2000 <- osrmTable(src = radios_vul8, dst = escuelas_2000)
df_tiempos_2000 <- as.data.frame(tabla_tiempos_2000$durations)
df_tiempos_2000$radio_id <- rownames(df_tiempos_2000)
df_tiempos_largo_2000 <- df_tiempos_2000 %>%
  pivot_longer(cols = -radio_id, names_to = "escuela_id", values_to = "tiempo_min") %>%
  mutate(buffer = "2000m")

# 7. Unir los resultados en un único dataframe
df_tiempos_final <- bind_rows(df_tiempos_largo_500,
                              df_tiempos_largo_1000,
                              df_tiempos_largo_2000)


```


```{r Geoconsulta tiempos a pie}


# 1. Configurar OSRM en modo a pie
options(osrm.profile = "foot")

# 2. Transformar ambos datasets a CRS 4326 (WGS84)
radios_vul8 <- st_transform(radios_vul8, 4326)
escuelasvul_500 <- st_transform(escuelasvul_500, 4326)

```


```{r}
#de una sola vez
# 500 m
tabla_tiempos <- osrmTable(src = radios_vul8, dst = escuelasvul_500)
df_tiempos <- as.data.frame(tabla_tiempos$durations)
df_tiempos$radio_id <- rownames(df_tiempos)
df_tiempos_largo <- df_tiempos %>%
  pivot_longer(cols = -radio_id, names_to = "escuela_id", values_to = "tiempo_min")

# 1000 m
tabla_tiempos2 <- osrmTable(src = radios_vul8, dst = escuelasvul_1000)
df_tiempos2 <- as.data.frame(tabla_tiempos2$durations)
df_tiempos2$radio_id <- rownames(df_tiempos2)
df_tiempos_largo2 <- df_tiempos2 %>%
  pivot_longer(cols = -radio_id, names_to = "escuela_id", values_to = "tiempo_min")

# 2000 m
tabla_tiempos3 <- osrmTable(src = radios_vul8, dst = escuelasvul_2000)
df_tiempos3 <- as.data.frame(tabla_tiempos3$durations)
df_tiempos3$radio_id <- rownames(df_tiempos3)
df_tiempos_largo3 <- df_tiempos3 %>%
  pivot_longer(cols = -radio_id, names_to = "escuela_id", values_to = "tiempo_min")
```


```{r}
# Primero agregamos la etiqueta del buffer a cada tabla
df_tiempos_largo  <- df_tiempos_largo  %>% mutate(buffer = "500m")
df_tiempos_largo2 <- df_tiempos_largo2 %>% mutate(buffer = "1000m")
df_tiempos_largo3 <- df_tiempos_largo3 %>% mutate(buffer = "2000m")

# Unificamos en una sola tabla
df_tiempos_total_vul <- bind_rows(
  df_tiempos_largo,
  df_tiempos_largo2,
  df_tiempos_largo3
)

```

