---
title: "Tp_movilidad_cdde2"
author: "Lucas S. Melfi"
date: "2025-05-31"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r Librerías}
library(tidyverse)
library(here)
library(sf)
library(nngeo)
library(leaflet)
library(fs)

```


```{r Urls}


url_barrios2 <- "https://cdn.buenosaires.gob.ar/datosabiertos/datasets/ministerio-de-desarrollo-humano-y-habitat/barrios-populares"

url_comunas <- "https://cdn.buenosaires.gob.ar/datosabiertos/datasets/ministerio-de-educacion/comunas/comunas.geojson"

url_barrioscaba <- "https://cdn.buenosaires.gob.ar/datosabiertos/datasets/ministerio-de-educacion/barrios/barrios.geojson"

url_educativos <- "https://cdn.buenosaires.gob.ar/datosabiertos/datasets/ministerio-de-educacion/establecimientos-educativos/establecimientos_educativos.geojson"

url_radiocensalcaba <- "https://cdn.buenosaires.gob.ar/datosabiertos/datasets/direccion-general-de-estadisticas-y-censos/informacion-censal-por-radio/caba_radios_censales.geojson"

url_radiosamba <- "https://cdn.produccion.gob.ar/cdn-cep/amba-aportantes/Shapes.rar"

url_radiosocioeco <- "https://cdn.produccion.gob.ar/cdn-cep/amba-aportantes/Empleo-AMBA.csv"



```


```{r}
#1 Carga de datos
#1.1 Mapa base Radio Censales AMBA

td <- tempdir()
rar_path <- path(td, "Shapes.rar")
download.file(url = url_radiosamba, destfile = rar_path, mode = "wb")
system(paste('"D:/PROGRAMS-HDD/WinRAR/WinRAR.exe" x', shQuote(rar_path), shQuote(td)))
list.files(td, pattern = "\\.shp$", recursive = TRUE)
radios2 <- read_sf(path(td, "Shapes", "Shape AMBA.shp"))
list.files(td, recursive = TRUE)
rm(td)
st_crs(radios2)
sum(!st_is_valid(radios2))
radios2 <- st_transform(radios2, 5347)
```


```{r}
#Dataset ingreso medio AMBA (2022)
radio_socioeco <- read.csv(url_radiosocioeco, fileEncoding = "latin1")
```

```{r}
#Join Df Espacial/No Espacial: Mapa de Radio Censales e Ingresos 

mapa_eco <- left_join(radios2, radio_socioeco, by = c("CO_FRAC_RA" = "LINK" ) ) %>%
  filter(!is.na(Remuneracion_media)) 

```



```{r}

#Ordenamos y clasificamos los clusters

baires_ecorad <- mapa_eco  %>% filter(provincia_id == 2, Remuneracion_media > 30000 ) #Filtrado de CABA
 
baires_q <- baires_ecorad %>% mutate(cluster = case_when( 
  Remuneracion_media <= quantile(Remuneracion_media, 0.25, na.rm = TRUE) ~ "Clase baja",
  Remuneracion_media <= quantile(Remuneracion_media, 0.50, na.rm = TRUE) ~ "Clase media",  
  Remuneracion_media <= quantile(Remuneracion_media, 0.75, na.rm = TRUE) ~ "Clase media alta", 
  TRUE ~ "Clase alta"
  ))


barrios_caba <- st_read(url_barrioscaba)
st_crs(barrios_caba)
sum(!st_is_valid(barrios_caba))
barrios_caba <- st_transform(barrios_caba, 5347)
barrios_q2 <- st_join(baires_q, barrios_caba, join = st_intersects)
barrios_q3 <- barrios_q2 %>% 
  select(CO_FRAC_RA, geometry, Remuneracion_media, cluster, nombre, comuna, perimetro_, area_metro) %>%
  rename(barrios_nom = nombre)



```



```{r}
#Agrupamos y elegimos comunas
barrios_q4 <- barrios_q3 %>%
  filter(barrios_nom == "Palermo" & cluster == "Clase alta" | 
           barrios_nom == "Caballito" & cluster == "Clase media alta"|
           barrios_nom == "Almagro" & cluster == "Clase media" ) %>%
  group_by(barrios_nom) %>%
  arrange(desc (Remuneracion_media)) %>%
  slice_head(n=8) %>%
  ungroup()

```





```{r}
#Cargamos un mapa de radiocensales de CABA para que nos oficie de mapa base
radio_bsas <-  st_read(url_radiocensalcaba)
st_crs(radio_bsas)
sum(!st_is_valid(radio_bsas))
radio_bsas <- st_transform(radio_bsas, 5347)
```
```{r}
#Primera visualizacion: Distribucion socio economica de caba  
ggplot() + 
  geom_sf(data = radio_bsas, fill = "grey90", color = "black") +
  geom_sf(data = barrios_q4, aes(fill = barrios_nom), color = "white", size = 0.2) +
  scale_fill_brewer(palette = "Set1") +
  theme_minimal()
```
```{r}
#Hacemos los buffers respecto de cada radio censal elegido
buffers_multi <- bind_rows(
  barrios_q4 %>% st_buffer(dist = 500) %>% mutate(distancia = "500m"), 
  barrios_q4 %>% st_buffer(dist = 1000) %>% mutate(distancia = "1000m"), 
  barrios_q4 %>% st_buffer(dist = 2000) %>% mutate(distancia = "2000m")
)

#cargamos las escuelas
educ <- st_read(url_educativos)
sum(!st_is_valid(educ))
educ2 <- st_transform(educ, 5347) %>% 
  select(escuela = nam , tipo_gestion = ges,  nivel = nen_mde, tipo = tip, geom_edu = geometry)

barrios_educ <- st_join(buffers_multi, educ2, join = st_intersects)
educ2_sna <- educ2 %>% filter(!is.na(tipo_gestion))
escuelas_con_barrios <- st_join(educ2_sna, buffers_multi, join = st_intersects)%>%
  filter(!is.na(distancia))
```

```{r}
#Visualizacion
ggplot() +
  geom_sf(data = radio_bsas, fill = "grey95", color = "grey80", size = 0.1) +
  geom_sf(data = barrios_educ, aes(fill = distancia), alpha = 0.05) +
  geom_sf(data = escuelas_con_barrios, aes(fill = tipo_gestion), alpha = 0.01) +
  labs(title = "Escuelas por tipo de gestión dentro de los buffers",
       fill = "Gestión escolar") +
  theme_minimal()
```



```{r}
ggplot() +
  geom_sf(data = radio_bsas, fill = "grey95", color = "grey80", size = 0.1) +
  geom_sf(data = barrios_educ, aes(color = distancia), alpha = 0.01, size = 1) +
  geom_sf(data = escuelas_con_barrios, aes(fill = tipo_gestion), color = NA, alpha = 0.5) +
  scale_fill_manual(values = c(
    "Estatal" = "#7570b3", 
    "Privada" = "#d95f02"
  )) +
  facet_wrap(~ distancia) +
  theme_minimal()
```

```{r}
p2 <- p1 +
  geom_sf(data = barrios_educ, aes(color = distancia), alpha = 0.01, size = 1)
print(p2)
```




```{r}

conteo_escuelas2 <- barrios_educ %>%
  group_by(barrios_nom, distancia) %>%  # reemplazá ID_barrio por la columna que identifica barrios
  summarize(cantidad_escuelas = n(), .groups = "drop")
```


```{r}

```


```{r Barrios Populares}
td <- tempdir()
  download.file(url = paste(url_barrios2,
                            "barrios-populares-badata.zip",
                            sep = "/"),
                destfile = fs::path(td, "barrios-populares-badata.zip") )
  unzip(zipfile = fs::path(td, "barrios-populares-badata.zip"),
        exdir = td)
  barrios <- read_sf(fs::path(td, "barrios_vulnerables.shp"))
  rm(td)
st_crs(barrios)
sum(!st_is_valid(barrios))
barrios <- st_transform(barrios, 4326)

```
#Barrios populares 
Capa que contiene el registro de los denominados barrios poulares de la Ciudad Autonoma de Buenos Aires. Dichos barrios son considerados las zonas precarias y vulnerables.
#TIPO_ASENT		
Tipo de registro: Villa, Asentamiento precario, Barrio municipal, Barrio urbanizado, Conjunto habitacional, Núcleo habitacional transitorio. Son categorías definidas según el Ministerio de Desarrollo y Hábitat en Junio de 2020.


```{r}
#Primera visualizacion barrios pop en radio censales
ggplot() +
  geom_sf(data = radios, fill = "grey90", color = "black", size = 0.1) +
  geom_sf(data = barrios, fill = "red", color = "darkred", alpha = 0.) +
  labs(title = "Ubicación de barrios populares  de CABA - Radiocensales",
       fill = "Comuna") +
  theme_minimal()
```


```{r Carga de datos 2}



socioeco_caba <- read.csv(url_socioecocaba, fileEncoding = "latin1")


  
```
#Barrios populares 
Capa que contiene el registro de los denominados barrios poulares de la Ciudad Autonoma de Buenos Aires. Dichos barrios son considerados las zonas precarias y vulnerables.
#TIPO_ASENT		
Tipo de registro: Villa, Asentamiento precario, Barrio municipal, Barrio urbanizado, Conjunto habitacional, Núcleo habitacional transitorio. Son categorías definidas según el Ministerio de Desarrollo y Hábitat en Junio de 2020.

#Comunas
Este conjunto de datos proporciona información sobre la ubicación, perímetro y área de las comunas de la Ciudad de Buenos Aires, establecidas a partir de la Ley Orgánica de Comunas (Ley Nº 1777/2005). La información permite analizar la distribución territorial y la organización administrativa de la ciudad, facilitando estudios de planificación urbana y gestión pública.



```{r Operaciones}
barrios <- st_transform(barrios, 4326)
st_crs(barrios)
comunas <- st_transform(comunas, 4326)
st_crs(comunas)
educ <- st_transform(educ, 4326)
HEAD
#Nos aseguramos que todos los barrios estan en el mismo CRC

radios <- st_transform(radios, 4326)
st_crs(radios)



barrios_j <- st_join(barrios, comunas, join = st_intersects) #Unimos solo las partes de la geometría que se intersectan entre barrios populares y comunas.
barrios_selec <- barrios_j %>% filter(NOMBRE %in% c("Villa 31", "Villa 21-24", "Villa 15 - Ciudad Oculta")) %>%
  mutate(NOMBRE = case_when(
    NOMBRE == "Villa 15 - Ciudad Oculta" ~ "Villa_15",
    NOMBRE == "Villa 31 - Padre Mugica" ~ "Villa_31",
    NOMBRE == "Villa 21-24" ~ "Villa_21-24"
  )) #Renombramos para que sea mas facil manejar el dato

barrios_selec <- barrios_selec %>%
  mutate(NOMBRE = coalesce(NOMBRE, "Villa_31")) #esto para que renombre los NA como Villa 31 que es el primer string
centroides_bar <- st_centroid(barrios_selec) #trazamos centroides en barrios para la posterior medicion de distancias
distancias <- st_distance(centroides_bar, educ) #Medimos (las escuelas estan en geometria punto)
cercanias <-  st_nearest_feature(centroides_bar, educ) #Vemos cuales son las mas cercanas, quedan en el vector
centroides_bar2 <- centroides_bar %>% #el vector almacena numero y posicionamiento, lo cruzamos con centroides y
  mutate(escuela_cercana = educ$nam[cercanias]) #...traemos los nombres de las escuelas más cercanas.

centroides_bar3 <- centroides_bar2 %>% mutate(distancia_m = as.numeric (st_distance(geometry, educ[cercanias, ], by_element = TRUE)), 
                                              distancia_km = distancia_m / 1000)
#da numeros con unidades, si no pongo  el as.numeric y segun claude y gpt eso dificulta para operaciones posteriores (preguntar a Pablo)

#Ahora ya tenemos los colegios con las distancias mas cercanas!

names(socioeco_caba)
glimpse(socioeco_caba)
socioec_com <- group_by(socioeco_caba, comuna) %>%
  summarise(
    ingreso_mediano = median(ingresos_familiares, na.rm  = TRUE),
    ingreso_medio = mean(ingresos_familiares, nar.rm = TRUE ),
    ) #Sacamos  medias y medianas de ingresos familiares luego de agrupar por comunas
com_ingreso <- left_join(comunas, socioec_com, by = "comuna")
#Unimos un join espacial con uno no espacial!

# barrios_cmya <- com_ingreso %>% filter(barrios %in% c("Caballito", "Almagro, Boedo", "Recoleta")) %>% st_centroid()
#Seleccionamos barrios peroy como es una geometria multipoligon le hacems centroides (esto no va porque necesito los barrios cmya como multipoligons para leafleet)
 
barrios_cmym <- com_ingreso %>% filter(barrios %in% c("Caballito", "Almagro, Boedo", "Recoleta"))
barrios_cmya <- st_centroid(barrios_cmym)
#Esto lo hacemos para representar en leafleet

cmya_cercanias <-  st_nearest_feature(barrios_cmya, educ) 
barrios_cmyaed2 <- barrios_cmya %>% mutate(escuela_cercana = educ$nam[cmya_cercanias], 
                                          distancia_m = as.numeric(st_distance(geometry,
                                                                               educ[cmya_cercanias, ],
                                                                               by_element =TRUE)),
                                          distancia_km = as.numeric(st_distance(geometry,                                                                                educ[cmya_cercanias,],
                                                                                by_element = TRUE)
                                          ) / 1000
)
#Aca  vamos a hacer integrar ambos datasets para ver la distancias
escuelas_cercanas <- educ %>% filter(nam %in% barrios_cmyaed2$escuela_cercana) #Para Leafleet
escuelas_cercanas2 <- educ %>% filter(nam %in% barrios_pcomp$escuela_cercana)
comparacion_distancias <- bind_rows(centroides_bar3 %>% mutate(niv_socioeco = "Barrio Popular"),
                                    barrios_cmyaed2 %>% mutate(niv_socioeco = case_when 
                                                               (barrios== "Recoleta" ~ "Clase Alta",
                                                                 barrios == "Almagro, Boedo" ~ "Clase Media",
                                                                 barrios == "Caballito" ~ "Clase Media Alta",
                                                                 TRUE ~ "Desconocido" )))
#Ocurre que no tienen los mismos campos. Vamos a armar una tabla:
#1) Renombramos y colectamos las mismas columnas

barrios_pcomp <- centroides_bar3 %>%
  rename( barrio = NOMBRE,) %>%
  mutate(niv_socioeco = "Barrio Popular") %>%
  select(barrio, comuna, niv_socioeco, escuela_cercana,  distancia_m, distancia_km, geometry)

barrios_cmyaed2 <- barrios_cmyaed2 %>%
  rename( barrio = barrios,) %>%
  mutate( niv_socioeco = case_when(
      barrio == "Recoleta" ~ "Clase Alta",
      barrio == "Almagro, Boedo" ~ "Clase Media",
      barrio == "Caballito" ~ "Clase Media Alta", TRUE ~ "Desconocido")) %>% 
        select(barrio, comuna, niv_socioeco, escuela_cercana,  distancia_m, distancia_km, geometry)

#Ahora sí, unimos
comparacion_distancias <- bind_rows(barrios_pcomp, barrios_cmyaed2)

# Esto no 
#barrios_cmyaed3 <- barrios_cmyaed2 %>%
#  left_join(educ %>% select(nam, geometry), by = c("escuela_cercana" = "nam")) %>%
#  rename(geom_escuela = geometry.y) %>%
#  st_as_sf(crs = st_crs(barrios_cmyaed2))

```






